<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8"/>
    <meta http-equiv="X-UA-Compatible" content="IE=edge"/>
    <meta
            name="viewport"
            content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no"
    />
    <title>3D Box Game</title>

    <link rel="stylesheet" href="styles.css"/>
    <link
            rel="stylesheet"
            href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/all.min.css"
    />
    <link
            rel="stylesheet"
            href="https://fonts.googleapis.com/css?family=Kalam|Caveat&display=swap"
    />
</head>

<body>
<!-- Home -->
<!-- Heading -->
<div id="heading">
    <h1 class="h1-heading">3D-Box Game</h1>
</div>

<!-- Reset -->
<div class="overlay">
    <button id="reset-button">Reset</button>
</div>

<!-- Score -->
<div id="score-container">
    <div id="score">Score: 0</div>
    <div id="highscore">High Score: 0</div>
</div>

<!-- Three.js canvas attaches here -->
<div id="game-root"></div>

<!-- On-screen Controls (mobile + desktop responsive mode) -->
<div class="mobile-ui" id="mobileUI" aria-hidden="true">
    <!-- Joystick -->
    <div class="joystick" id="joystick">
        <div class="stick" id="stick"></div>
    </div>

    <!-- Jump -->
    <button class="jump" id="btnJump" aria-label="Jump">â¤’</button>
</div>

<!-- Three.js importmap -->
<script
        async
        src="https://unpkg.com/es-module-shims@1.6.3/dist/es-module-shims.js"
></script>

<script type="importmap">
    {
      "imports": {
        "three": "https://unpkg.com/three@0.150.1/build/three.module.js",
        "three/addons/": "https://unpkg.com/three@0.150.1/examples/jsm/"
      }
    }
</script>

<script type="module">
    // ===== Heading animation =====
    const text = document.querySelector(".h1-heading");
    const strText = text.textContent;
    const splitText = strText.split("");
    text.textContent = "";
    for (let i = 0; i < splitText.length; i++) {
      text.innerHTML += "<span>" + splitText[i] + "</span>";
    }
    let char = 0;
    let timer = setInterval(() => {
      const span = text.querySelectorAll("span")[char];
      if (!span) return;
      span.classList.add("fade");
      char++;
      if (char === splitText.length) {
        clearInterval(timer);
        timer = null;
      }
    }, 120);

    import * as THREE from "three";
    import { OrbitControls } from "three/addons/controls/OrbitControls.js";

    const root = document.getElementById("game-root");

    const scene = new THREE.Scene();

    const camera = new THREE.PerspectiveCamera(
      75,
      window.innerWidth / window.innerHeight,
      0.1,
      1000
    );
    camera.position.set(0.05, 3, 8);

    const renderer = new THREE.WebGLRenderer({ alpha: true, antialias: true });
    renderer.shadowMap.enabled = true;
    root.appendChild(renderer.domElement);

    const controls = new OrbitControls(camera, renderer.domElement);

    // ===== Responsive resize =====
    function resize() {
      const w = window.innerWidth;
      const h = window.innerHeight;
      renderer.setSize(w, h);
      renderer.setPixelRatio(Math.min(2, window.devicePixelRatio || 1));
      camera.aspect = w / h;
      camera.updateProjectionMatrix();
    }
    window.addEventListener("resize", resize);
    resize();

    // ===== GAME OBJECTS =====
    class Box extends THREE.Mesh {
      constructor({
        width,
        height,
        depth,
        color = "#00ff00",
        velocity = { x: 0, y: 0, z: 0 },
        position = { x: 0, y: 0, z: 0 },
        zAcceleration = false,
      }) {
        super(
          new THREE.BoxGeometry(width, height, depth),
          new THREE.MeshStandardMaterial({ color })
        );

        this.width = width;
        this.height = height;
        this.depth = depth;

        this.position.set(position.x, position.y, position.z);

        this.velocity = velocity;
        this.gravity = -0.005;
        this.zAcceleration = zAcceleration;

        this.updateSides();
      }

      updateSides() {
        this.right = this.position.x + this.width / 2;
        this.left = this.position.x - this.width / 2;

        this.bottom = this.position.y - this.height / 2;
        this.top = this.position.y + this.height / 2;

        this.front = this.position.z + this.depth / 2;
        this.back = this.position.z - this.depth / 2;
      }

      update(ground) {
        this.updateSides();

        if (this.zAcceleration) this.velocity.z += 0.0007;

        this.position.x += this.velocity.x;
        this.position.z += this.velocity.z;

        this.applyGravity(ground);
      }

      applyGravity(ground) {
        this.velocity.y += this.gravity;

        if (boxCollision({ box1: this, box2: ground })) {
          const friction = 0.7;
          this.velocity.y *= friction;
          this.velocity.y = -this.velocity.y;
        } else {
          this.position.y += this.velocity.y;
        }
      }
    }

    function boxCollision({ box1, box2 }) {
      const zCollision = box1.front >= box2.back && box1.back <= box2.front;
      const yCollision =
        box1.bottom + box1.velocity.y <= box2.top && box1.top >= box2.bottom;
      const xCollision = box1.right >= box2.left && box1.left <= box2.right;

      return xCollision && zCollision && yCollision;
    }

    const cube = new Box({
      width: 1,
      height: 1,
      depth: 1,
      velocity: { x: 0, y: -0.02, z: 0 },
    });
    cube.castShadow = true;
    scene.add(cube);

    const ground = new Box({
      width: 10,
      height: 1,
      depth: 50,
      color: "#202020",
      position: { x: 0, y: -2, z: 0 },
    });
    ground.receiveShadow = true;
    scene.add(ground);

    const light = new THREE.DirectionalLight(0xffffff, 1);
    light.position.set(0, 3, 1);
    light.castShadow = true;
    scene.add(light);

    scene.add(new THREE.AmbientLight(0xffffff, 0.5));

    // ===== INPUT (keyboard) =====
    const keys = {
      a: { pressed: false },
      d: { pressed: false },
      s: { pressed: false },
      w: { pressed: false },
      up: { pressed: false },
      down: { pressed: false },
      left: { pressed: false },
      right: { pressed: false },
    };

    window.addEventListener("keydown", (event) => {
      switch (event.code) {
        case "KeyA":
          keys.a.pressed = true;
          break;
        case "KeyD":
          keys.d.pressed = true;
          break;
        case "KeyS":
          keys.s.pressed = true;
          break;
        case "KeyW":
          keys.w.pressed = true;
          break;
        case "ArrowUp":
          keys.up.pressed = true;
          break;
        case "ArrowDown":
          keys.down.pressed = true;
          break;
        case "ArrowLeft":
          keys.left.pressed = true;
          break;
        case "ArrowRight":
          keys.right.pressed = true;
          break;
        case "Space":
          cube.velocity.y = 0.12;
          break;
      }
    });

    window.addEventListener("keyup", (event) => {
      switch (event.code) {
        case "KeyA":
          keys.a.pressed = false;
          break;
        case "KeyD":
          keys.d.pressed = false;
          break;
        case "KeyS":
          keys.s.pressed = false;
          break;
        case "KeyW":
          keys.w.pressed = false;
          break;
        case "ArrowUp":
          keys.up.pressed = false;
          break;
        case "ArrowDown":
          keys.down.pressed = false;
          break;
        case "ArrowLeft":
          keys.left.pressed = false;
          break;
        case "ArrowRight":
          keys.right.pressed = false;
          break;
      }
    });

    // ===== ON-SCREEN CONTROLS (mobile + desktop responsive mode) =====
    const mobileUI = document.getElementById("mobileUI");
    const joystick = document.getElementById("joystick");
    const stick = document.getElementById("stick");
    const btnJump = document.getElementById("btnJump");

    const mqSmall = window.matchMedia("(max-width: 900px)");
    const isTouchDevice =
      "ontouchstart" in window || navigator.maxTouchPoints > 0;

    function shouldShowControls() {
      return isTouchDevice || mqSmall.matches;
    }

    function updateControlsVisibility() {
      const show = shouldShowControls();
      mobileUI.style.display = show ? "block" : "none";
      mobileUI.setAttribute("aria-hidden", show ? "false" : "true");
    }

    mqSmall.addEventListener?.("change", updateControlsVisibility);
    window.addEventListener("resize", updateControlsVisibility);
    updateControlsVisibility();

    // Disable OrbitControls when on-screen controls are active (prevents conflict)
    function syncOrbitControls() {
      controls.enabled = !shouldShowControls();
    }
    mqSmall.addEventListener?.("change", syncOrbitControls);
    window.addEventListener("resize", syncOrbitControls);
    syncOrbitControls();

    const joy = { x: 0, y: 0, active: false };

    function clamp(v, min, max) {
      return Math.max(min, Math.min(max, v));
    }

    function setKeyFromJoystick() {
      const dz = 0.18;
      const x = Math.abs(joy.x) < dz ? 0 : joy.x;
      const y = Math.abs(joy.y) < dz ? 0 : joy.y;

      keys.left.pressed = x < 0;
      keys.right.pressed = x > 0;
      keys.up.pressed = y < 0;
      keys.down.pressed = y > 0;
    }

    function onJoyMove(clientX, clientY) {
      const rect = joystick.getBoundingClientRect();
      const cx = rect.left + rect.width / 2;
      const cy = rect.top + rect.height / 2;

      const dx = clientX - cx;
      const dy = clientY - cy;

      const maxR = rect.width * 0.35;
      const dist = Math.hypot(dx, dy);
      const factor = dist > maxR ? maxR / dist : 1;

      const mx = dx * factor;
      const my = dy * factor;

      stick.style.transform = `translate(${mx}px, ${my}px)`;

      joy.x = clamp(mx / maxR, -1, 1);
      joy.y = clamp(my / maxR, -1, 1);
      setKeyFromJoystick();
    }

    function resetJoystick() {
      stick.style.transform = `translate(0px, 0px)`;
      joy.x = 0;
      joy.y = 0;
      joy.active = false;
      setKeyFromJoystick();
    }

    joystick.addEventListener("pointerdown", (e) => {
      if (!shouldShowControls()) return;
      e.preventDefault();
      joy.active = true;
      joystick.setPointerCapture(e.pointerId);
      onJoyMove(e.clientX, e.clientY);
    });

    joystick.addEventListener("pointermove", (e) => {
      if (!joy.active) return;
      e.preventDefault();
      onJoyMove(e.clientX, e.clientY);
    });

    joystick.addEventListener("pointerup", (e) => {
      e.preventDefault();
      resetJoystick();
    });

    joystick.addEventListener("pointercancel", resetJoystick);

    // touch fallback for older browsers
    joystick.addEventListener(
      "touchstart",
      (e) => {
        if (!shouldShowControls()) return;
        e.preventDefault();
        joy.active = true;
        const t = e.touches[0];
        onJoyMove(t.clientX, t.clientY);
      },
      { passive: false }
    );

    joystick.addEventListener(
      "touchmove",
      (e) => {
        if (!joy.active) return;
        e.preventDefault();
        const t = e.touches[0];
        onJoyMove(t.clientX, t.clientY);
      },
      { passive: false }
    );

    joystick.addEventListener(
      "touchend",
      (e) => {
        e.preventDefault();
        resetJoystick();
      },
      { passive: false }
    );

    function doJump() {
      cube.velocity.y = 0.12;
    }

    btnJump.addEventListener("pointerdown", (e) => {
      if (!shouldShowControls()) return;
      e.preventDefault();
      doJump();
    });

    btnJump.addEventListener(
      "touchstart",
      (e) => {
        if (!shouldShowControls()) return;
        e.preventDefault();
        doJump();
      },
      { passive: false }
    );

    // ===== GAME LOOP =====
    const enemies = [];
    let frames = 0;
    let spawnRate = 200;
    let animationID;
    let score = 0;
    let highScore = 0;

    function animate() {
      animationID = requestAnimationFrame(animate);
      renderer.render(scene, camera);

      cube.velocity.x = 0;
      cube.velocity.z = 0;

      const speed = 0.06;

      if (keys.a.pressed || keys.left.pressed) cube.velocity.x = -speed;
      else if (keys.d.pressed || keys.right.pressed) cube.velocity.x = speed;

      if (keys.s.pressed || keys.down.pressed) cube.velocity.z = speed;
      else if (keys.w.pressed || keys.up.pressed) cube.velocity.z = -speed;

      cube.update(ground);

      enemies.forEach((enemy) => {
        enemy.update(ground);
        if (boxCollision({ box1: cube, box2: enemy })) endGame();
      });

      if (frames % spawnRate === 0) {
        if (spawnRate > 20) spawnRate -= 15;

        const enemy = new Box({
          width: 1,
          height: 1,
          depth: 1,
          position: {
            x: (Math.random() - 0.5) * 9,
            y: 0,
            z: -20,
          },
          velocity: { x: 0, y: 0, z: 0.015 },
          color: "red",
          zAcceleration: true,
        });

        enemy.castShadow = true;
        scene.add(enemy);
        enemies.push(enemy);

        score++;
        document.getElementById("score").textContent = `Score: ${score}`;

        if (score > highScore) {
          highScore = score;
          document.getElementById(
            "highscore"
          ).textContent = `High Score: ${highScore}`;
        }
      }

      frames++;
    }

    function endGame() {
      cancelAnimationFrame(animationID);
      const gameOverText = document.createElement("h2");
      gameOverText.innerHTML = "GAME OVER";
      gameOverText.classList.add("gameover");
      document.body.appendChild(gameOverText);
    }

    document.getElementById("reset-button").addEventListener("click", resetGame);

    function resetGame() {
      const gameOverText = document.querySelector(".gameover");
      if (gameOverText) gameOverText.remove();

      cube.position.set(0, 0, 0);
      cube.velocity.x = 0;
      cube.velocity.y = -0.02;
      cube.velocity.z = 0;

      enemies.forEach((enemy) => scene.remove(enemy));
      enemies.length = 0;

      frames = 0;
      spawnRate = 200;

      score = 0;
      document.getElementById("score").textContent = `Score: ${score}`;

      animate();
    }

    animate();
</script>
</body>
</html>
